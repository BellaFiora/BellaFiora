import {Observable} from 'rxjs/Observable';
import 'rxjs/add/operator/map';

// Gets the proper XMLHttpRequest for support for older IE
function getXMLHttpRequest() {
  if (root.XMLHttpRequest) {
    return new root.XMLHttpRequest();
  } else {
    var progId;
    try {
      var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
      for(var i = 0; i < 3; i++) {
        try {
          progId = progIds[i];
          if (new root.ActiveXObject(progId)) {
            break;
          }
        } catch(e) { }
      }
      return new root.ActiveXObject(progId);
    } catch (e) {
      throw new Error('XMLHttpRequest is not supported by your browser');
    }
  }
}

// Get CORS support even for older IE
function getCORSRequest() {
  var xhr = new root.XMLHttpRequest();
  if ('withCredentials' in xhr) {
    xhr.withCredentials = this.withCredentials ? true : false;
    return xhr;
  } else if (!!root.XDomainRequest) {
    return new XDomainRequest();
  } else {
    throw new Error('CORS is not supported by your browser');
  }
}

function normalizeAjaxSuccessEvent(e, xhr, settings) {
  var response = ('response' in xhr) ? xhr.response : xhr.responseText;
  response = settings.responseType === 'json' ? JSON.parse(response) : response;
  return {
    response: response,
    status: xhr.status,
    responseType: xhr.responseType,
    xhr: xhr,
    originalEvent: e
  };
}

function normalizeAjaxErrorEvent(e, xhr, type) {
  return {
    type: type,
    status: xhr.status,
    xhr: xhr,
    originalEvent: e
  };
}

function AjaxDisposable(state, xhr) {
  this._state = state;
  this._xhr = xhr;
  this.isDisposed = false;
}

AjaxDisposable.prototype.unsubscribe = function () {
  if (!this.isDisposed) {
    this.isDisposed = true;
    if (!this._state.isDone && this._xhr.readyState !== 4) { this._xhr.abort(); }
  }
};

function createAjaxObservable(settings) {
  return Observable.create((o) => {
    var state = { isDone: false };
    var xhr;

    var normalizeError = settings.normalizeError;
    var normalizeSuccess = settings.normalizeSuccess;

    var processResponse = function(xhr, e){
      var status = xhr.status === 1223 ? 204 : xhr.status;
      if ((status >= 200 && status <= 300) || status === 0 || status === '') {
        o.next(normalizeSuccess(e, xhr, settings));
        o.complete();
      } else {
        o.error(settings.normalizeError(e, xhr, 'error'));
      }
      state.isDone = true;
    };

    try {
      xhr = settings.createXHR();
    } catch (err) {
      return o.error(err);
    }

    try {
      if (settings.user) {
        xhr.open(settings.method, settings.url, settings.async, settings.user, settings.password);
      } else {
        xhr.open(settings.method, settings.url, settings.async);
      }

      if (settings.responseType === 'blob') {
        xhr.responseType = 'blob';
      }

      var headers = settings.headers;
      for (var header in headers) {
        if (hasOwnProperty.call(headers, header)) {
          xhr.setRequestHeader(header, headers[header]);
        }
      }

      xhr.timeout = settings.timeout;
      xhr.ontimeout = function (e) {
        settings.progressObserver && settings.progressObserver.error(e);
        o.error(normalizeError(e, xhr, 'timeout'));
      };

      if(!!xhr.upload || (!('withCredentials' in xhr) && !!root.XDomainRequest)) {
        xhr.onload = function(e) {
          if(settings.progressObserver) {
            settings.progressObserver.next(e);
            settings.progressObserver.complete();
          }
          processResponse(xhr, e);
        };

        if(settings.progressObserver) {
          xhr.onprogress = function(e) {
            settings.progressObserver.next(e);
          };
        }

        xhr.onerror = function(e) {
          settings.progressObserver && settings.progressObserver.error(e);
          o.error(normalizeError(e, xhr, 'error'));
          state.isDone = true;
        };

        xhr.onabort = function(e) {
          settings.progressObserver && settings.progressObserver.error(e);
          o.error(normalizeError(e, xhr, 'abort'));
          state.isDone = true;
        };
      } else {
        xhr.onreadystatechange = function (e) {
          xhr.readyState === 4 && processResponse(xhr, e);
        };
      }

      var contentType = settings.headers['Content-Type'] ||
      settings.headers['Content-type'] ||
      settings.headers['content-type'];
      if (settings.hasContent && contentType === 'application/x-www-form-urlencoded' && typeof settings.body !== 'string') {
        var newBody = [];
        for (var prop in settings.body) {
          if (hasOwnProperty.call(settings.body, prop)) {
            newBody.push(prop + '=' + settings.body[prop]);
          }
        }
        settings.body = newBody.join('&');
      }

      xhr.send(settings.hasContent && settings.body || null);
    } catch (e) {
      o.error(e);
    }

    return new AjaxDisposable(state, xhr);
  });
}

/**
* Creates an observable for an Ajax request with either a settings object with url, headers, etc or a string for a URL.
*
* @example
*   source = Rx.DOM.ajax('/products');
*   source = Rx.DOM.ajax( url: 'products', method: 'GET' });
*
* @param {Object} settings Can be one of the following:
*
*  A string of the URL to make the Ajax call.
*  An object with the following properties
*   - url: URL of the request
*   - body: The body of the request
*   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
*   - async: Whether the request is async
*   - headers: Optional headers
*   - crossDomain: true if a cross domain request, else false
*
* @returns {Observable} An observable sequence containing the XMLHttpRequest.
*/
export function ajax(options) {
  var settings = {
    method: 'GET',
    crossDomain: false,
    async: true,
    headers: {},
    responseType: 'text',
    timeout: 0,
    withCredentials: false,
    createXHR: function() {
      return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
    },
    normalizeError: normalizeAjaxErrorEvent,
    normalizeSuccess: normalizeAjaxSuccessEvent
  };

  if(typeof options === 'string') {
    settings.url = options;
  } else {
    for(var prop in options) {
      if(hasOwnProperty.call(options, prop)) {
        settings[prop] = options[prop];
      }
    }
  }

  if (!settings.crossDomain && !settings.headers['X-Requested-With']) {
    settings.headers['X-Requested-With'] = 'XMLHttpRequest';
  }
  settings.hasContent = settings.body !== undefined;

  return createAjaxObservable(settings);
}

var ajaxRequest = ajax;

/**
* Creates an observable sequence from an Ajax POST Request with the body.
*
* @param {String} url The URL to POST
* @param {Object} body The body to POST
* @returns {Observable} The observable sequence which contains the response from the Ajax POST.
*/
export function post(url, body) {
  var settings;
  if (typeof url === 'string') {
    settings = {url: url, body: body, method: 'POST' };
  } else if (typeof url === 'object') {
    settings = url;
    settings.method = 'POST';
  }
  return ajaxRequest(settings);
}

/**
* Creates an observable sequence from an Ajax GET Request with the body.
*
* @param {String} url The URL to GET
* @returns {Observable} The observable sequence which contains the response from the Ajax GET.
*/
export function get(url) {
  var settings;
  if (typeof url === 'string') {
    settings = {url: url };
  } else if (typeof url === 'object') {
    settings = url;
  }
  return ajaxRequest(settings);
}

/**
* Creates an observable sequence from JSON from an Ajax request
*
* @param {String} url The URL to GET
* @returns {Observable} The observable sequence which contains the parsed JSON.
*/
export function getJSON(url) {
  if (!root.JSON && typeof root.JSON.parse !== 'function') { throw new TypeError('JSON is not supported in your runtime.'); }
  return ajaxRequest({url: url, responseType: 'json'}).map(function (x) {
    return x.response;
  });
}
